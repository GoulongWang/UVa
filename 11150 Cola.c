#include <stdio.h>
#include <math.h>
int main(){
	int n;
	while(scanf("%d", &n) != EOF) printf("%.0f\n", ceil(1.5 * n - 0.5));
	return 0;
}

/*
原始版解法 : 
畫圖觀察 n = 1 ~ n = 10 即可找出算法。
1. n = 偶數時才要借一個
2. 一直換空瓶子到最後只會剩下一個空瓶(剛好可以還別人)，所以 n == 1 時為結束條件

#include <stdio.h>
int main(){
	int n;
	while(scanf("%d", &n) != EOF){
		int ans = n;
		if (n % 2 == 0) n++;
		while(n > 1) ans += n / 3, n = n / 3 + n % 3;
		printf("%d\n", ans);
	}
	return 0;
}


精簡版解法 : 
觀察 n = 1 ~ n = 10 的結果，發現呈現類似等差數列關係
n   |(1) (2) (3) (4) (5) (6) (7) (8) (9) (10)
An  | 1   3   4   6   7   9   10  12  13  15
d   |   2   1   2   1   2   1    2   1   2

會發現奇數項的公差都是 3 ，因此稍微改一下數列變成新的數列
n   |(1) (2)  (3) (4)  (5) (6)  (7) (8)   (9)  (10)
An  | 1   2.5  4   5.5  7   8.5  10  11.5  13   14.5
此時的公差變為 1.5

再把新數列和原數列做比較
n   |(1) (2)  (3) (4)  (5) (6)  (7) (8)   (9)  (10)
新  | 1   2.5  4   5.5  7   8.5  10  11.5  13   14.5
原  | 1   3    4   6    7   9    10  12    13   15

發現只要把新數列取 ceil() 就會變成原數列的結果了!
ceil(An) = ceil(A1 + 1.5(n - 1)) = ceil(1.5n - 0.5)
*/
